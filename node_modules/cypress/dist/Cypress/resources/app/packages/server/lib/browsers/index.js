(function() {
  var Promise, _, cleanup, errors, fs, getBrowser, instance, kill, log, path, utils;

  _ = require("lodash");

  fs = require("fs-extra");

  path = require("path");

  Promise = require("bluebird");

  log = require("debug")("cypress:server:browsers");

  utils = require("./utils");

  errors = require("../errors");

  fs = Promise.promisifyAll(fs);

  instance = null;

  kill = function(unbind) {
    if (!instance) {
      return Promise.resolve();
    }
    return new Promise(function(resolve) {
      if (unbind) {
        instance.removeAllListeners();
      }
      instance.once("exit", resolve);
      instance.kill();
      return cleanup();
    });
  };

  cleanup = function() {
    return instance = null;
  };

  getBrowser = function(name) {
    switch (name) {
      case "chrome":
      case "chromium":
      case "canary":
        return require("./chrome");
      case "electron":
        return require("./electron");
    }
  };

  process.once("exit", kill);

  module.exports = {
    get: utils.getBrowsers,
    launch: utils.launch,
    close: kill,
    open: function(name, options, automation) {
      if (options == null) {
        options = {};
      }
      return kill(true).then(function() {
        var browser, names, url;
        _.defaults(options, {
          browserArgs: [],
          onBrowserOpen: function() {},
          onBrowserClose: function() {}
        });
        if (!(browser = getBrowser(name))) {
          names = _.map(options.browsers, "name").join(", ");
          return errors["throw"]("BROWSER_NOT_FOUND", name, names);
        }
        if (!(url = options.url)) {
          throw new Error("options.url must be provided when opening a browser. You passed:", options);
        }
        log("open browser %s", name);
        return browser.open(name, url, options, automation).then(function(i) {
          log("browser opened");
          instance = i;
          instance.once("exit", function() {
            options.onBrowserClose();
            return cleanup();
          });
          return Promise.delay(1000).then(function() {
            options.onBrowserOpen();
            return instance;
          });
        });
      });
    }
  };

}).call(this);
